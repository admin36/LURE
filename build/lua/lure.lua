-- Generated by Haxe 3.4.2 (git build master @ 890f8c7)
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local _hx_exports = _hx_exports or {}
local Array = _hx_e()
local Attr = _hx_e()
local _DOMTokenList = {}
_DOMTokenList.DOMTokenList_Impl_ = _hx_e()
local EventTarget = _hx_e()
local Node = _hx_e()
local Document = _hx_e()
local Element = _hx_e()
local Exceptions = _hx_e()
local HTMLLexer = _hx_e()
local HTMLParser = _hx_e()
local List = _hx_e()
local _List = {}
_List.ListNode = _hx_e()
_List.ListIterator = _hx_e()
local _NamedNodeMap = {}
_NamedNodeMap.NamedNodeMap_Impl_ = _hx_e()
local _NodeList = {}
_NodeList.NodeList_Impl_ = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local haxe = {}
haxe.IMap = _hx_e()
haxe.ds = {}
haxe.ds.StringMap = _hx_e()
haxe.io = {}
haxe.io.Input = _hx_e()
haxe.io.Eof = _hx_e()
local lua = {}
lua.Boot = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self,0);
end
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

Attr.new = {}

_DOMTokenList.DOMTokenList_Impl_.new = {}
_DOMTokenList.DOMTokenList_Impl_._new = function() 
  local this1 = Array.new();
  do return this1 end;
end

EventTarget.new = function() 
  local self = _hx_new()
  EventTarget.super(self)
  return self
end
EventTarget.super = function(self) 
end
_hx_exports["EventTarget"] = EventTarget

Node.new = function() 
  local self = _hx_new(Node.prototype)
  Node.super(self)
  return self
end
Node.super = function(self) 
  self.childNodes = _NodeList.NodeList_Impl_._new();
  EventTarget.super(self);
end
_hx_exports["Node"] = Node
Node.prototype = _hx_a(
  'appendChild', function(self,child) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'cloneNode', function(self,deep) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'compareDocumentPosition', function(self,node) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'contains', function(self,node) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'hasChildNodes', function(self) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'insertBefore', function(self,newNode,referenceNode) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'isDefaultNamespace', function(self,namespaceURI) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'isEqualNode', function(self,otherNode) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'isSameNode', function(self,other) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'lookupNamespaceURI', function(self,prefix) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'lookupPrefix', function(self) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'normalize', function(self) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'removeChild', function(self,child) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'replaceChild', function(self,newChild,oldChild) 
    _G.error(Exceptions.NotImplemented,0);
  end
)
Node.__super__ = EventTarget
setmetatable(Node.prototype,{__index=EventTarget.prototype})

Document.new = function() 
  local self = _hx_new(Document.prototype)
  Document.super(self)
  return self
end
Document.super = function(self) 
  Node.super(self);
end
_hx_exports["Document"] = Document
Document.prototype = _hx_a(
  
)
Document.__super__ = Node
setmetatable(Document.prototype,{__index=Node.prototype})

Element.new = function() 
  local self = _hx_new(Element.prototype)
  Element.super(self)
  return self
end
Element.super = function(self) 
  self.tagName = "";
  self.namespaceURI = nil;
  self.localName = "";
  self.innerHTML = "";
  self.id = "";
  self.computedRole = "";
  self.computedName = "";
  self.className = "";
  self.classList = _DOMTokenList.DOMTokenList_Impl_._new();
  self.attributes = _NamedNodeMap.NamedNodeMap_Impl_._new();
  Node.super(self);
end
_hx_exports["Element"] = Element
Element.prototype = _hx_a(
  'getAttribute', function(self,name) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'getAttributeNames', function(self) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'getAttributeNS', function(self,namespace,name) 
    _G.error(Exceptions.NotImplemented,0);
  end,
  'set_innerHTML', function(self,html) 
    _G.error(Exceptions.NotImplemented,0);
  end
)
Element.__super__ = Node
setmetatable(Element.prototype,{__index=Node.prototype})

Exceptions.new = {}
_hx_exports["Exceptions"] = Exceptions

HTMLLexer.new = function(input) 
  local self = _hx_new()
  HTMLLexer.super(self,input)
  return self
end
HTMLLexer.super = function(self,input) 
end

HTMLParser.new = function() 
  local self = _hx_new(HTMLParser.prototype)
  HTMLParser.super(self)
  return self
end
HTMLParser.super = function(self) 
  self.lex = HTMLLexer.new(nil);
  self.stack = List.new();
end
_hx_exports["HTMLParser"] = HTMLParser
HTMLParser.prototype = _hx_a(
  'parseFromString', function(self,str) 
    local doc = Document.new();
    local input = String.new(str);
    local pos = 0;
    local textBuffer = "";
    while (pos < input.length) do 
      if (input:charAt(pos) == "<") then 
        if (textBuffer.length > 0) then 
          pos = pos + self:openNode(input:substr(pos),3);
        else
          if (self:isCloseNodeAtIndex(input,pos)) then 
            pos = pos + self:closeNode(pos);
          else
            if (self:isCommentNodeAtIndex(input,pos)) then 
              pos = pos + self:openNode(input:substr(pos),8);
            else
              if (self:isCdataNodeAtIndex(input,pos)) then 
                pos = pos + self:openNode(input:substr(pos),4);
              else
                if (self:isDoctypeDeclarationNodeAtIndex(input,pos)) then 
                  pos = pos + self:openNode(input:substr(pos),7);
                else
                  pos = pos + self:openNode(input:substr(pos),1);
                end;
              end;
            end;
          end;
        end;
      else
        textBuffer = textBuffer .. input:charAt(pos);
        pos = pos + 1;
      end;
      end;
    do return doc end
  end,
  'isCloseNodeAtIndex', function(self,input,index) 
    do return input:charAt(index + 1) == "/" end
  end,
  'isCommentNodeAtIndex', function(self,input,index) 
    do return input:indexOf("!--",index) ~= -1 end
  end,
  'isCdataNodeAtIndex', function(self,input,index) 
    do return input:indexOf("![CDATA[",index) ~= -1 end
  end,
  'isDoctypeDeclarationNodeAtIndex', function(self,input,index) 
    do return input:indexOf("!DOCTYPE",index) ~= -1 end
  end,
  'openNode', function(self,input,type) 
    local tmp = type == 1;
    do return 0 end
  end,
  'makeElement', function(self,tagName) 
    do return Element.new() end
  end,
  'closeNode', function(self,index) 
    do return index end
  end
)

List.new = function() 
  local self = _hx_new(List.prototype)
  List.super(self)
  return self
end
List.super = function(self) 
  self.length = 0;
end
List.prototype = _hx_a(
  'iterator', function(self) 
    do return _List.ListIterator.new(self.h) end
  end
)

_List.ListNode.new = {}

_List.ListIterator.new = function(head) 
  local self = _hx_new(_List.ListIterator.prototype)
  _List.ListIterator.super(self,head)
  return self
end
_List.ListIterator.super = function(self,head) 
  self.head = head;
end
_List.ListIterator.prototype = _hx_a(
  'hasNext', function(self) 
    do return self.head ~= nil end
  end,
  'next', function(self) 
    local val = self.head.item;
    self.head = self.head.next;
    do return val end
  end
)

_NamedNodeMap.NamedNodeMap_Impl_.new = {}
_NamedNodeMap.NamedNodeMap_Impl_._new = function() 
  local this1 = haxe.ds.StringMap.new();
  do return this1 end;
end

_NodeList.NodeList_Impl_.new = {}
_NodeList.NodeList_Impl_._new = function() 
  local this1 = Array.new();
  do return this1 end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'indexOf', function(self,str,startIndex) 
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then 
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'toString', function(self) 
    do return self end
  end,
  'charAt', function(self,index) 
    do return _G.string.sub(self,index + 1,index + 1) end
  end,
  'substr', function(self,pos,len) 
    if ((len == nil) or (len > (pos + self.length))) then 
      len = self.length;
    else
      if (len < 0) then 
        len = self.length + len;
      end;
    end;
    if (pos < 0) then 
      pos = self.length + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    do return _G.string.sub(self,pos + 1,pos + len) end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end

haxe.IMap.new = {}

haxe.ds.StringMap.new = function() 
  local self = _hx_new()
  haxe.ds.StringMap.super(self)
  return self
end
haxe.ds.StringMap.super = function(self) 
  self.v = {}
  self.k = {}
end
haxe.ds.StringMap.__interfaces__ = {haxe.IMap}

haxe.io.Input.new = {}

haxe.io.Eof.new = {}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  Node.ATTRIBUTE_NODE = 2
  Node.CDATA_SECTION_NODE = 4
  Node.COMMENT_NODE = 8
  Node.DOCUMENT_NODE = 9
  Node.DOCUMENT_TYPE_NODE = 10
  Node.DOCUMENT_FRAGMENT_NODE = 11
  Node.ELEMENT_NODE = 1
  Node.ENTITY_REFERENCE_NODE = 5
  Node.ENTITY_NODE = 6
  Node.NOTATION_NODE = 12
  Node.PROCESSING_INSTRUCTION_NODE = 7
  Node.TEXT_NODE = 3
  Exceptions.NotImplemented = "Not Implemented"
  HTMLParser.elements = _hx_tab_array({[0]="a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp" }, 143)
  HTMLParser.attr2elem = (function() 
    local _hx_2
    
    local _g = haxe.ds.StringMap.new();
    
    _g.v["accept"] = _hx_tab_array({[0]="form", "input" }, 2);
    _g.k["accept"] = true;
    
    _g.v["accept-charset"] = _hx_tab_array({[0]="form" }, 1);
    _g.k["accept-charset"] = true;
    
    _g.v["accesskey"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["accesskey"] = true;
    
    _g.v["action"] = _hx_tab_array({[0]="form" }, 1);
    _g.k["action"] = true;
    
    _g.v["align"] = _hx_tab_array({[0]="applet", "caption", "col", "colgroup", "hr", "iframe", "img", "table", "tbody", "td", "tfoot", "th", "thead", "tr" }, 14);
    _g.k["align"] = true;
    
    _g.v["alt"] = _hx_tab_array({[0]="applet", "area", "img", "input" }, 4);
    _g.k["alt"] = true;
    
    _g.v["async"] = _hx_tab_array({[0]="script" }, 1);
    _g.k["async"] = true;
    
    _g.v["autocomplete"] = _hx_tab_array({[0]="form", "input" }, 2);
    _g.k["autocomplete"] = true;
    
    _g.v["autofocus"] = _hx_tab_array({[0]="button", "input", "keygen", "select", "textarea" }, 5);
    _g.k["autofocus"] = true;
    
    _g.v["autoplay"] = _hx_tab_array({[0]="audio", "video" }, 2);
    _g.k["autoplay"] = true;
    
    _g.v["autosave"] = _hx_tab_array({[0]="input" }, 1);
    _g.k["autosave"] = true;
    
    _g.v["bgcolor"] = _hx_tab_array({[0]="body", "col", "colgroup", "marquee", "table", "tbody", "tfoot", "td", "th", "tr" }, 10);
    _g.k["bgcolor"] = true;
    
    _g.v["border"] = _hx_tab_array({[0]="img", "object", "table" }, 3);
    _g.k["border"] = true;
    
    _g.v["buffered"] = _hx_tab_array({[0]="audio", "video" }, 2);
    _g.k["buffered"] = true;
    
    _g.v["challenge"] = _hx_tab_array({[0]="keygen" }, 1);
    _g.k["challenge"] = true;
    
    _g.v["charset"] = _hx_tab_array({[0]="meta", "script" }, 2);
    _g.k["charset"] = true;
    
    _g.v["checked"] = _hx_tab_array({[0]="command", "input" }, 2);
    _g.k["checked"] = true;
    
    _g.v["cite"] = _hx_tab_array({[0]="blockquote", "del", "ins", "q" }, 4);
    _g.k["cite"] = true;
    
    _g.v["class"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["class"] = true;
    
    _g.v["code"] = _hx_tab_array({[0]="applet" }, 1);
    _g.k["code"] = true;
    
    _g.v["codebase"] = _hx_tab_array({[0]="applet" }, 1);
    _g.k["codebase"] = true;
    
    _g.v["color"] = _hx_tab_array({[0]="basefont", "font", "hr" }, 3);
    _g.k["color"] = true;
    
    _g.v["cols"] = _hx_tab_array({[0]="textarea" }, 1);
    _g.k["cols"] = true;
    
    _g.v["colspan"] = _hx_tab_array({[0]="td", "th" }, 2);
    _g.k["colspan"] = true;
    
    _g.v["content"] = _hx_tab_array({[0]="meta" }, 1);
    _g.k["content"] = true;
    
    _g.v["contenteditable"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["contenteditable"] = true;
    
    _g.v["contextmenu"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["contextmenu"] = true;
    
    _g.v["controls"] = _hx_tab_array({[0]="audio", "video" }, 2);
    _g.k["controls"] = true;
    
    _g.v["coords"] = _hx_tab_array({[0]="area" }, 1);
    _g.k["coords"] = true;
    
    _g.v["crossorigin"] = _hx_tab_array({[0]="audio", "img", "link", "script", "video" }, 5);
    _g.k["crossorigin"] = true;
    
    _g.v["data"] = _hx_tab_array({[0]="object" }, 1);
    _g.k["data"] = true;
    
    _g.v["data-*"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["data-*"] = true;
    
    _g.v["datetime"] = _hx_tab_array({[0]="del", "ins", "time" }, 3);
    _g.k["datetime"] = true;
    
    _g.v["default"] = _hx_tab_array({[0]="track" }, 1);
    _g.k["default"] = true;
    
    _g.v["defer"] = _hx_tab_array({[0]="script" }, 1);
    _g.k["defer"] = true;
    
    _g.v["dir"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["dir"] = true;
    
    _g.v["dirname"] = _hx_tab_array({[0]="input", "textarea" }, 2);
    _g.k["dirname"] = true;
    
    _g.v["disabled"] = _hx_tab_array({[0]="button", "command", "fieldset", "input", "keygen", "optgroup", "option", "select", "textarea" }, 9);
    _g.k["disabled"] = true;
    
    _g.v["download"] = _hx_tab_array({[0]="a", "area" }, 2);
    _g.k["download"] = true;
    
    _g.v["draggable"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["draggable"] = true;
    
    _g.v["dropzone"] = _hx_tab_array({[0]="*" }, 1);
    _g.k["dropzone"] = true;
    
    _g.v["enctype"] = _hx_tab_array({[0]="form" }, 1);
    _g.k["enctype"] = true;
    
    _g.v["for"] = _hx_tab_array({[0]="label", "output" }, 2);
    _g.k["for"] = true;
    
    _g.v["form"] = _hx_tab_array({[0]="button", "fieldset", "input", "keygen", "label", "meter", "object", "progress", "select", "textarea" }, 10);
    _g.k["form"] = true;
    
    _g.v["formaction"] = _hx_tab_array({[0]="input", "button" }, 2);
    _g.k["formaction"] = true;
    
    _g.v["headers"] = _hx_tab_array({[0]="td", "th" }, 2);
    _g.k["headers"] = true;
    
    _g.v["height"] = _hx_tab_array({[0]="canvas", "embed", "iframe", "img", "input", "object", "video" }, 7);
    _g.k["height"] = true;
    
    _g.v["hidden"] = _hx_tab_array({ }, 0);
    _g.k["hidden"] = true;
    
    _g.v["high"] = _hx_tab_array({ }, 0);
    _g.k["high"] = true;
    
    _g.v["href"] = _hx_tab_array({ }, 0);
    _g.k["href"] = true;
    
    _g.v["hreflang"] = _hx_tab_array({ }, 0);
    _g.k["hreflang"] = true;
    
    _g.v["http-equiv"] = _hx_tab_array({ }, 0);
    _g.k["http-equiv"] = true;
    
    _g.v["icon"] = _hx_tab_array({ }, 0);
    _g.k["icon"] = true;
    
    _g.v["id"] = _hx_tab_array({ }, 0);
    _g.k["id"] = true;
    
    _g.v["integrity"] = _hx_tab_array({ }, 0);
    _g.k["integrity"] = true;
    
    _g.v["ismap"] = _hx_tab_array({ }, 0);
    _g.k["ismap"] = true;
    
    _g.v["itemprop"] = _hx_tab_array({ }, 0);
    _g.k["itemprop"] = true;
    
    _g.v["keytype"] = _hx_tab_array({ }, 0);
    _g.k["keytype"] = true;
    
    _g.v["kind"] = _hx_tab_array({ }, 0);
    _g.k["kind"] = true;
    
    _g.v["label"] = _hx_tab_array({ }, 0);
    _g.k["label"] = true;
    
    _g.v["lang"] = _hx_tab_array({ }, 0);
    _g.k["lang"] = true;
    
    _g.v["language"] = _hx_tab_array({ }, 0);
    _g.k["language"] = true;
    
    _g.v["list"] = _hx_tab_array({ }, 0);
    _g.k["list"] = true;
    
    _g.v["loop"] = _hx_tab_array({ }, 0);
    _g.k["loop"] = true;
    
    _g.v["low"] = _hx_tab_array({ }, 0);
    _g.k["low"] = true;
    
    _g.v["manifest"] = _hx_tab_array({ }, 0);
    _g.k["manifest"] = true;
    
    _g.v["max"] = _hx_tab_array({ }, 0);
    _g.k["max"] = true;
    
    _g.v["maxlength"] = _hx_tab_array({ }, 0);
    _g.k["maxlength"] = true;
    
    _g.v["minlength"] = _hx_tab_array({ }, 0);
    _g.k["minlength"] = true;
    
    _g.v["media"] = _hx_tab_array({ }, 0);
    _g.k["media"] = true;
    
    _g.v["method"] = _hx_tab_array({ }, 0);
    _g.k["method"] = true;
    
    _g.v["min"] = _hx_tab_array({ }, 0);
    _g.k["min"] = true;
    
    _g.v["multiple"] = _hx_tab_array({ }, 0);
    _g.k["multiple"] = true;
    
    _g.v["muted"] = _hx_tab_array({ }, 0);
    _g.k["muted"] = true;
    
    _g.v["name"] = _hx_tab_array({ }, 0);
    _g.k["name"] = true;
    
    _g.v["novalidate"] = _hx_tab_array({ }, 0);
    _g.k["novalidate"] = true;
    
    _g.v["open"] = _hx_tab_array({ }, 0);
    _g.k["open"] = true;
    
    _g.v["optimum"] = _hx_tab_array({ }, 0);
    _g.k["optimum"] = true;
    
    _g.v["pattern"] = _hx_tab_array({ }, 0);
    _g.k["pattern"] = true;
    
    _g.v["ping"] = _hx_tab_array({ }, 0);
    _g.k["ping"] = true;
    
    _g.v["placeholder"] = _hx_tab_array({ }, 0);
    _g.k["placeholder"] = true;
    
    _g.v["poster"] = _hx_tab_array({ }, 0);
    _g.k["poster"] = true;
    
    _g.v["preload"] = _hx_tab_array({ }, 0);
    _g.k["preload"] = true;
    
    _g.v["radiogroup"] = _hx_tab_array({ }, 0);
    _g.k["radiogroup"] = true;
    
    _g.v["readonly"] = _hx_tab_array({ }, 0);
    _g.k["readonly"] = true;
    
    _g.v["rel"] = _hx_tab_array({ }, 0);
    _g.k["rel"] = true;
    
    _g.v["required"] = _hx_tab_array({ }, 0);
    _g.k["required"] = true;
    
    _g.v["reversed"] = _hx_tab_array({ }, 0);
    _g.k["reversed"] = true;
    
    _g.v["rows"] = _hx_tab_array({ }, 0);
    _g.k["rows"] = true;
    
    _g.v["rowspan"] = _hx_tab_array({ }, 0);
    _g.k["rowspan"] = true;
    
    _g.v["sandbox"] = _hx_tab_array({ }, 0);
    _g.k["sandbox"] = true;
    
    _g.v["scope"] = _hx_tab_array({ }, 0);
    _g.k["scope"] = true;
    
    _g.v["scoped"] = _hx_tab_array({ }, 0);
    _g.k["scoped"] = true;
    
    _g.v["seamless"] = _hx_tab_array({ }, 0);
    _g.k["seamless"] = true;
    
    _g.v["selected"] = _hx_tab_array({ }, 0);
    _g.k["selected"] = true;
    
    _g.v["shape"] = _hx_tab_array({ }, 0);
    _g.k["shape"] = true;
    
    _g.v["size"] = _hx_tab_array({ }, 0);
    _g.k["size"] = true;
    
    _g.v["sizes"] = _hx_tab_array({ }, 0);
    _g.k["sizes"] = true;
    
    _g.v["slot"] = _hx_tab_array({ }, 0);
    _g.k["slot"] = true;
    
    _g.v["span"] = _hx_tab_array({ }, 0);
    _g.k["span"] = true;
    
    _g.v["spellcheck"] = _hx_tab_array({ }, 0);
    _g.k["spellcheck"] = true;
    
    _g.v["src"] = _hx_tab_array({ }, 0);
    _g.k["src"] = true;
    
    _g.v["srcdoc"] = _hx_tab_array({ }, 0);
    _g.k["srcdoc"] = true;
    
    _g.v["srclang"] = _hx_tab_array({ }, 0);
    _g.k["srclang"] = true;
    
    _g.v["srcset"] = _hx_tab_array({ }, 0);
    _g.k["srcset"] = true;
    
    _g.v["start"] = _hx_tab_array({ }, 0);
    _g.k["start"] = true;
    
    _g.v["step"] = _hx_tab_array({ }, 0);
    _g.k["step"] = true;
    
    _g.v["style"] = _hx_tab_array({ }, 0);
    _g.k["style"] = true;
    
    _g.v["summary"] = _hx_tab_array({ }, 0);
    _g.k["summary"] = true;
    
    _g.v["tabindex"] = _hx_tab_array({ }, 0);
    _g.k["tabindex"] = true;
    
    _g.v["target"] = _hx_tab_array({ }, 0);
    _g.k["target"] = true;
    
    _g.v["title"] = _hx_tab_array({ }, 0);
    _g.k["title"] = true;
    
    _g.v["type"] = _hx_tab_array({ }, 0);
    _g.k["type"] = true;
    
    _g.v["usemap"] = _hx_tab_array({ }, 0);
    _g.k["usemap"] = true;
    
    _g.v["value"] = _hx_tab_array({ }, 0);
    _g.k["value"] = true;
    
    _g.v["width"] = _hx_tab_array({ }, 0);
    _g.k["width"] = true;
    
    _g.v["wrap"] = _hx_tab_array({ }, 0);
    _g.k["wrap"] = true;
    
    _hx_2 = _g;
    return _hx_2
  end )()
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
end

_hx_static_init();
return _hx_exports
